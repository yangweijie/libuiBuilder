# 状态管理策略

<cite>
**本文档中引用的文件**  
- [StateManager.php](file://src/State/StateManager.php)
- [ComponentRef.php](file://src/State/ComponentRef.php)
- [ComponentBuilder.php](file://src/ComponentBuilder.php)
- [Builder.php](file://src/Builder.php)
- [eventAndState.php](file://example/eventAndState.php)
- [StateHelperTest.php](file://tests/StateHelperTest.php)
- [helper.php](file://src/helper.php)
</cite>

## 目录
1. [简介](#简介)
2. [状态管理架构](#状态管理架构)
3. [核心组件分析](#核心组件分析)
4. [状态管理实践](#状态管理实践)
5. [组件间通信机制](#组件间通信机制)
6. [事件与状态监听](#事件与状态监听)
7. [最佳实践总结](#最佳实践总结)

## 简介
libuiBuilder 提供了一套完整的状态管理解决方案，通过集中式状态管理器实现组件间的数据共享与同步。本文档详细说明状态管理的最佳实践，包括状态的设置与获取、变化监听、数据绑定以及内存泄漏防护等关键机制。

## 状态管理架构

```mermaid
graph TD
subgraph "状态管理层"
StateManager[StateManager<br/>状态管理器]
ComponentRef[ComponentRef<br/>组件引用]
end
subgraph "构建器层"
ComponentBuilder[ComponentBuilder<br/>组件构建基类]
Builder[Builder<br/>构建器入口]
end
subgraph "应用层"
EventAndState[eventAndState.php<br/>示例应用]
end
StateManager --> ComponentRef : "管理"
ComponentBuilder --> StateManager : "调用"
ComponentBuilder --> ComponentRef : "创建"
Builder --> ComponentBuilder : "继承"
EventAndState --> StateManager : "使用"
EventAndState --> ComponentBuilder : "配置"
```

**图示来源**  
- [StateManager.php](file://src/State/StateManager.php#L1-L91)
- [ComponentRef.php](file://src/State/ComponentRef.php#L1-L74)
- [ComponentBuilder.php](file://src/ComponentBuilder.php#L1-L234)

**本节来源**  
- [StateManager.php](file://src/State/StateManager.php#L1-L91)
- [ComponentBuilder.php](file://src/ComponentBuilder.php#L1-L234)

## 核心组件分析

### StateManager 分析

```mermaid
classDiagram
class StateManager {
-instance : StateManager
-state : array
-watchers : array
-componentRefs : array
+instance() : StateManager
+set(key : string, value : any) : void
+get(key : string, default : any) : any
+watch(key : string, callback : callable) : void
+update(updates : array) : void
+registerComponent(id : string, component : ComponentRef) : void
+getComponent(id : string) : ComponentRef
+dump() : array
}
class ComponentRef {
-id : string
-component : ComponentBuilder
-handle : CData
+getId() : string
+getComponent() : ComponentBuilder
+getHandle() : CData
+setHandle(handle : CData) : void
+getValue() : any
+setValue(value : any) : void
+getConfig(key : string) : any
+call(method : string, ...args) : any
}
StateManager "1" -- "0..*" ComponentRef : "注册"
ComponentBuilder --> ComponentRef : "创建"
```

**图示来源**  
- [StateManager.php](file://src/State/StateManager.php#L1-L91)
- [ComponentRef.php](file://src/State/ComponentRef.php#L1-L74)

**本节来源**  
- [StateManager.php](file://src/State/StateManager.php#L1-L91)
- [ComponentRef.php](file://src/State/ComponentRef.php#L1-L74)

### ComponentBuilder 状态管理机制

```mermaid
flowchart TD
Start([组件构建]) --> SetId["id() 设置组件ID"]
SetId --> Register["注册到 StateManager"]
Register --> Bind["bind() 绑定状态"]
Bind --> Watch["监听状态变化"]
Watch --> UpdateComponent["更新组件值"]
Bind --> Emit["触发 change 事件"]
Emit --> UpdateState["更新状态管理器"]
subgraph "状态变化流程"
StateChange["状态变化 set()"]
NotifyWatchers["通知所有监听者"]
CallCallbacks["执行回调函数"]
end
UpdateState --> StateChange
StateChange --> NotifyWatchers
NotifyWatchers --> CallCallbacks
CallCallbacks --> UpdateComponent
```

**图示来源**  
- [ComponentBuilder.php](file://src/ComponentBuilder.php#L122-L175)
- [StateManager.php](file://src/State/StateManager.php#L26-L37)

**本节来源**  
- [ComponentBuilder.php](file://src/ComponentBuilder.php#L122-L175)
- [StateManager.php](file://src/State/StateManager.php#L26-L37)

## 状态管理实践

### 状态设置与获取

状态管理器提供了统一的接口来管理应用状态，避免了全局变量的滥用。通过 `state()` 辅助函数可以方便地进行状态操作：

```mermaid
sequenceDiagram
participant App as "应用"
participant State as "StateManager"
App->>State : state('key', 'value')
State->>State : set('key', 'value')
State->>State : 通知监听者
App->>State : state('key')
State-->>App : 返回值
```

**图示来源**  
- [StateHelperTest.php](file://tests/StateHelperTest.php#L15-L78)
- [StateManager.php](file://src/State/StateManager.php#L26-L45)

**本节来源**  
- [StateHelperTest.php](file://tests/StateHelperTest.php#L15-L78)
- [StateManager.php](file://src/State/StateManager.php#L26-L45)

### 状态监听实现

状态监听机制允许组件在状态变化时自动更新，实现了响应式编程模式：

```mermaid
sequenceDiagram
participant Component as "组件"
participant State as "StateManager"
participant Listener as "监听器"
Component->>State : watch('key', callback)
State->>State : 存储监听器
State->>State : set('key', 'newValue')
State->>Listener : 执行所有回调
Listener->>Component : 更新组件状态
Component->>State : emit('change')
State->>State : 更新状态(如果绑定)
```

**图示来源**  
- [ComponentBuilder.php](file://src/ComponentBuilder.php#L136-L146)
- [StateManager.php](file://src/State/StateManager.php#L50-L56)

**本节来源**  
- [ComponentBuilder.php](file://src/ComponentBuilder.php#L136-L146)
- [StateManager.php](file://src/State/StateManager.php#L50-L56)

## 组件间通信机制

### 数据绑定最佳实践

推荐使用 `bind()` 方法进行数据绑定，而不是直接引用全局状态：

```mermaid
flowchart LR
A[输入组件] -- bind('username') --> B[StateManager]
C[标签组件] -- bind('username') --> B
D[按钮组件] -- watch('username') --> B
B --> A : 状态变化
B --> C : 自动更新
B --> D : 响应变化
style A fill:#f9f,stroke:#333
style B fill:#bbf,stroke:#333,color:#fff
style C fill:#f9f,stroke:#333
style D fill:#f9f,stroke:#333
```

**图示来源**  
- [eventAndState.php](file://example/eventAndState.php#L33-L34)
- [ComponentBuilder.php](file://src/ComponentBuilder.php#L136-L146)

**本节来源**  
- [eventAndState.php](file://example/eventAndState.php#L33-L34)
- [ComponentBuilder.php](file://src/ComponentBuilder.php#L136-L146)

### 组件引用通信

当需要直接操作其他组件时，应通过组件引用来实现：

```mermaid
sequenceDiagram
participant Input as "输入框"
participant Button as "按钮"
participant State as "StateManager"
Input->>State : id('usernameInput')
Button->>State : getComponent('usernameInput')
Button->>Input : getValue()
Input-->>Button : 返回值
Button->>Input : setValue('new value')
```

**图示来源**  
- [eventAndState.php](file://example/eventAndState.php#L39-L43)
- [ComponentRef.php](file://src/State/ComponentRef.php#L46-L57)

**本节来源**  
- [eventAndState.php](file://example/eventAndState.php#L39-L43)
- [ComponentRef.php](file://src/State/ComponentRef.php#L46-L57)

## 事件与状态监听

### 监听器注册与解绑

正确管理监听器生命周期，防止内存泄漏：

```mermaid
flowchart TD
A[初始化] --> B["$state->watch('isLoggedIn', callback)"]
B --> C[状态变化]
C --> D[执行回调]
D --> E{组件销毁?}
E --> |是| F["移除监听器"]
E --> |否| C
F --> G[防止内存泄漏]
style B fill:#ffdddd,stroke:#f66
style F fill:#ddffdd,stroke:#6f6
```

**图示来源**  
- [eventAndState.php](file://example/eventAndState.php#L226-L232)
- [StateManager.php](file://src/State/StateManager.php#L50-L56)

**本节来源**  
- [eventAndState.php](file://example/eventAndState.php#L226-L232)
- [StateManager.php](file://src/State/StateManager.php#L50-L56)

### 实际应用示例分析

基于 eventAndState.php 示例的完整状态流：

```mermaid
flowchart LR
subgraph "登录表单"
Username[用户名输入框] -- bind('username') --> SM
Password[密码输入框] -- bind('password') --> SM
Status[状态标签] -- watch('password') --> SM
end
subgraph "用户管理"
Search[搜索框] -- onChange --> SM
Table[用户表格] -- bind('userList') --> SM
Edit[编辑表单] -- watch('selectedUser') --> SM
end
LoginBtn[登录按钮] -- onClick --> SM
SM((StateManager)) -- set('isLoggedIn') --> LoginBtn
SM -- set('userList') --> Table
style SM fill:#4CAF50,stroke:#333,color:#fff
```

**图示来源**  
- [eventAndState.php](file://example/eventAndState.php#L13-L234)
- [StateManager.php](file://src/State/StateManager.php#L1-L91)

**本节来源**  
- [eventAndState.php](file://example/eventAndState.php#L13-L234)

## 最佳实践总结

1. **集中管理状态**：所有共享状态应通过 StateManager 进行管理，避免使用全局变量
2. **优先使用绑定**：组件间通信优先使用 `bind()` 方法进行数据绑定
3. **合理监听状态**：使用 `watch()` 监听状态变化，实现响应式更新
4. **及时清理资源**：在组件销毁时应考虑清理相关监听器，防止内存泄漏
5. **使用组件引用**：需要直接操作其他组件时，通过 `id()` 和 `getComponent()` 获取引用
6. **批量更新状态**：使用 `update()` 方法进行批量状态更新，提高性能

**本节来源**  
- [StateManager.php](file://src/State/StateManager.php#L1-L91)
- [ComponentBuilder.php](file://src/ComponentBuilder.php#L1-L234)
- [eventAndState.php](file://example/eventAndState.php#L1-L234)