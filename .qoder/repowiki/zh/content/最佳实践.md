# libuiBuilder 项目开发最佳实践

<cite>
**本文档中引用的文件**
- [README.md](file://README.md)
- [TabBuilder.php](file://src/Builder/TabBuilder.php)
- [GridBuilder.php](file://src/Components/GridBuilder.php)
- [StateManager.php](file://src/State/StateManager.php)
- [BoxBuilder.php](file://src/Components/BoxBuilder.php)
- [ComponentBuilder.php](file://src/ComponentBuilder.php)
- [ComponentRef.php](file://src/State/ComponentRef.php)
- [calculator.ui.html](file://example/views/calculator.ui.html)
- [htmlLogin.php](file://example/htmlLogin.php)
- [full.php](file://example/full.php)
</cite>

## 目录
1. [简介](#简介)
2. [推荐使用HTML模板作为主要开发方式](#推荐使用html模板作为主要开发方式)
3. [项目文件结构建议](#项目文件结构建议)
4. [事件处理逻辑封装](#事件处理逻辑封装)
5. [Grid布局优于深层嵌套Box布局](#grid布局优于深层嵌套box布局)
6. [状态管理最佳实践](#状态管理最佳实践)
7. [性能优化建议](#性能优化建议)
8. [总结](#总结)

## 简介

libuiBuilder是一个基于PHP的GUI应用程序构建框架，提供了两种主要的开发方式：HTML模板渲染和Builder API。本最佳实践文档旨在帮助开发者充分利用框架的优势，构建高质量、可维护的桌面应用程序。

## 推荐使用HTML模板作为主要开发方式

### 为什么推荐HTML模板？

HTML模板渲染是libuiBuilder的主要推荐开发方式，具有以下优势：

#### 1. 熟悉的语法和可视化预览
HTML模板使用熟悉的标记语言定义界面，开发者可以轻松理解和维护。模板可以在浏览器中预览，无需编译即可看到效果。

#### 2. 组件复用和模块化
HTML模板支持模板复用机制，可以创建可重用的UI组件片段，提高开发效率和代码一致性。

#### 3. 数据绑定简洁直观
通过简单的属性绑定实现数据同步，如`bind="username"`和`{{username}}`语法，使状态管理变得简单直观。

#### 4. 事件处理分离
HTML模板将界面定义与业务逻辑分离，便于团队协作和代码维护。

### HTML模板示例

```html
<window title="登录窗口" size="400,300" centered="true">
  <grid padded="true">
    <label row="0" col="0" align="end,center">用户名:</label>
    <input 
      id="usernameInput"
      row="0" 
      col="1" 
      bind="username"
      placeholder="请输入用户名"
      expand="horizontal"
    />
    
    <button row="1" col="0" colspan="2" onclick="handleLogin">
      登录
    </button>
  </grid>
</window>
```

### 不推荐Builder API的情况

Builder API更适合动态构建和编程灵活性需求，但在大多数情况下，HTML模板更优：

```php
// 不推荐（除非需要动态构建）
Builder::window()
    ->title('我的应用')
    ->size(800, 600)
    ->contains([
        Builder::grid()->...
    ]);
```

**节来源**
- [README.md](file://README.md#L303-L322)

## 项目文件结构建议

### 推荐的项目结构

为了保持代码的组织性和可维护性，建议采用以下项目结构：

```
project/
├── views/              # HTML模板文件
│   ├── login.ui.html
│   ├── dashboard.ui.html
│   └── components/
│       ├── header.html
│       └── footer.html
├── handlers/           # 事件处理器类
│   ├── LoginHandlers.php
│   ├── DashboardHandlers.php
│   └── BaseHandlers.php
├── state/              # 状态管理配置
│   ├── AppState.php
│   └── ValidationRules.php
├── assets/             # 静态资源
│   ├── css/
│   └── js/
└── app.php             # 应用程序入口点
```

### 文件组织原则

#### 1. Views目录
- 按功能模块组织HTML模板
- 使用语义化的文件名
- 支持模板继承和复用

#### 2. Handlers目录
- 按业务功能分类处理器
- 实现单一职责原则
- 提供清晰的接口定义

#### 3. State目录
- 集中管理全局状态配置
- 定义状态验证规则
- 维护状态变更历史

**节来源**
- [README.md](file://README.md#L324-L336)

## 事件处理逻辑封装

### 专用处理器类的设计

将事件处理逻辑封装在专门的处理器类中，可以提高代码的可读性和可维护性。

#### 处理器类设计模式

```php
class LoginHandlers {
    public static function getHandlers(): array {
        return [
            'handleLogin' => [self::class, 'login'],
            'handleReset' => [self::class, 'reset'],
            'handleUsernameChange' => [self::class, 'validateUsername'],
        ];
    }
    
    public static function login($button, $state) {
        // 登录业务逻辑
    }
    
    public static function reset($button, $state) {
        // 重置逻辑
    }
    
    public static function validateUsername($value, $component) {
        // 用户名验证逻辑
    }
}
```

#### 事件处理最佳实践

1. **单一职责**：每个处理器方法只处理一个特定的事件
2. **参数解耦**：明确传递所需的参数，避免过度依赖外部状态
3. **错误处理**：在处理器中包含适当的错误处理逻辑
4. **日志记录**：记录重要的事件处理过程以便调试

### 事件处理器注册

```php
$handlers = LoginHandlers::getHandlers();
$app = HtmlRenderer::render('views/login.ui.html', $handlers);
```

**节来源**
- [README.md](file://README.md#L340-L357)
- [htmlLogin.php](file://example/htmlLogin.php#L16-L95)

## Grid布局优于深层嵌套Box布局

### Grid布局的优势

Grid布局提供了更精确和可预测的界面控制，相比嵌套的Box布局具有明显优势：

#### 1. 精确的二维定位
Grid布局允许精确控制组件在二维空间中的位置，避免了Box布局的层级依赖问题。

#### 2. 更好的可维护性
Grid布局的结构更加扁平，减少了嵌套层次，提高了代码的可读性和维护性。

#### 3. 更灵活的布局控制
Grid布局支持跨行跨列的组件，能够轻松实现复杂的界面布局。

### Grid布局示例

```html
<grid>
  <label row="0" col="0">字段1:</label>
  <input row="0" col="1"/>
  <label row="1" col="0">字段2:</label>
  <input row="1" col="1"/>
</grid>
```

### 避免深层嵌套的Box布局

```html
<!-- 不推荐：深层嵌套的Box布局 -->
<vbox>
  <hbox>
    <label>字段1:</label>
    <input/>
  </hbox>
  <hbox>
    <label>字段2:</label>
    <input/>
  </hbox>
</vbox>
```

### Grid布局高级特性

#### 1. 跨行列组件
```html
<button row="2" col="0" colspan="3" align="center" expand="horizontal">
  提交
</button>
```

#### 2. 对齐和扩展控制
```html
<label row="0" col="0" align="end,center">用户名:</label>
<input row="0" col="1" bind="username" expand="horizontal"/>
```

#### 3. 表单布局简化
```php
public function form(array $fields): static
{
    foreach ($fields as $index => $field) {
        if (is_array($field) && isset($field['label'], $field['control'])) {
            $this->place($field['label'], $index, 0)->align('end', 'center');
            $this->place($field['control'], $index, 1)->expand(true, false);
        }
    }
    return $this;
}
```

**节来源**
- [README.md](file://README.md#L360-L386)
- [GridBuilder.php](file://src/Components/GridBuilder.php#L81-L90)

## 状态管理最佳实践

### 合理组织状态键

良好的状态组织有助于提高应用的可维护性和性能：

#### 1. 按功能域分组
```php
// 推荐：按功能域组织状态
$state->update([
    'user' => [
        'name' => '张三',
        'email' => 'zhangsan@example.com',
        'preferences' => [
            'theme' => 'dark',
            'language' => 'zh-CN'
        ]
    ],
    'settings' => [
        'autoSave' => true,
        'notifications' => false
    ]
]);
```

#### 2. 避免过深的状态嵌套
```php
// 不推荐：过深的嵌套
$state->set('user.profile.personal.address.street', '长安街1号');

// 推荐：扁平化状态结构
$state->set('userStreet', '长安街1号');
$state->set('userCity', '北京');
```

### 状态监听的最佳实践

#### 1. 选择性监听
只监听真正需要关注的状态变化，避免不必要的性能开销。

```php
// 推荐：选择性监听
$state->watch('currentUser', function($user) {
    // 只有当当前用户发生变化时才更新界面
    updateUserInfoPanel($user);
});

// 不推荐：监听所有状态变化
$state->watch('*', function($newValue, $oldValue, $key) {
    // 这会导致每次状态变化都触发处理
});
```

#### 2. 避免循环依赖
确保状态监听不会导致循环更新，造成无限递归。

```php
// 推荐：使用防抖机制
$state->watch('searchQuery', debounce(function($query) {
    performSearch($query);
}, 300));
```

### 状态管理器的使用

#### 1. 单例模式
StateManager采用单例模式，确保全局状态的一致性。

```php
$state = StateManager::instance();
$state->set('username', 'admin');
$username = $state->get('username');
```

#### 2. 批量更新
使用批量更新来减少状态变化的次数，提高性能。

```php
$state->update([
    'firstName' => '张',
    'lastName' => '三',
    'fullName' => '张三'
]);
```

#### 3. 组件引用管理
通过ComponentRef实现组件间的通信和状态共享。

```php
// 注册组件引用
$this->id('usernameInput')->bind('username');

// 在其他处理器中获取组件引用
$usernameInput = StateManager::instance()->getComponent('usernameInput');
if ($usernameInput) {
    $usernameInput->setValue('新用户名');
}
```

**节来源**
- [StateManager.php](file://src/State/StateManager.php#L15-L91)
- [ComponentRef.php](file://src/State/ComponentRef.php#L11-L74)

## 性能优化建议

### 减少不必要的组件重建

#### 1. 智能组件缓存
ComponentBuilder实现了智能的组件缓存机制，只有在必要时才重新构建组件。

```php
public function build(): CData
{
    if ($this->handle === null) {
        // 只有在handle为空时才创建新组件
        $this->handle = $this->createNativeControl();
        // ... 其他初始化逻辑
    }
    return $this->handle;
}
```

#### 2. 避免频繁的状态更新
```php
// 不推荐：频繁的状态更新
for ($i = 0; $i < 1000; $i++) {
    $state->set("item$i", $data[$i]);
}

// 推荐：批量更新
$dataUpdates = [];
for ($i = 0; $i < 1000; $i++) {
    $dataUpdates["item$i"] = $data[$i];
}
$state->update($dataUpdates);
```

### 优化状态监听

#### 1. 条件监听
只在特定条件下启用状态监听。

```php
if ($this->shouldListenToChanges()) {
    $state->watch('importantState', function($value) {
        // 只有在需要时才执行监听逻辑
    });
}
```

#### 2. 监听器清理
及时清理不再需要的监听器，避免内存泄漏。

```php
public function cleanup(): void
{
    // 清理状态监听器
    $state = StateManager::instance();
    $state->removeWatcher('myComponent', 'importantState');
    
    // 清理组件引用
    $state->unregisterComponent('myComponent');
}
```

### 组件引用优化

#### 1. 延迟加载
只在需要时才获取组件引用。

```php
protected function getRef(string $id): ?ComponentRef
{
    // 延迟加载组件引用
    return StateManager::instance()->getComponent($id);
}
```

#### 2. 引用缓存
对于频繁使用的组件引用，考虑本地缓存。

```php
private ?ComponentRef $cachedUsernameInput = null;

public function getUsernameInput(): ComponentRef
{
    if ($this->cachedUsernameInput === null) {
        $this->cachedUsernameInput = StateManager::instance()->getComponent('usernameInput');
    }
    return $this->cachedUsernameInput;
}
```

### 事件处理优化

#### 1. 事件委托
对于大量相似的事件，使用事件委托模式。

```php
// 推荐：事件委托
$container->on('click', function($event) {
    if ($event->target->matches('.dynamic-button')) {
        $this->handleButtonClick($event->target);
    }
});
```

#### 2. 防抖和节流
对于高频触发的事件，使用防抖和节流技术。

```php
// 防抖示例
$state->watch('searchTerm', debounce(function($term) {
    $this->performSearch($term);
}, 300));

// 节流示例
$state->watch('scrollPosition', throttle(function($position) {
    $this->updateScrollIndicators($position);
}, 100));
```

**节来源**
- [ComponentBuilder.php](file://src/ComponentBuilder.php#L209-L231)
- [StateManager.php](file://src/State/StateManager.php#L58-L66)

## 总结

libuiBuilder框架提供了强大而灵活的GUI开发能力。通过遵循以下最佳实践，可以构建出高质量、高性能的应用程序：

### 核心原则

1. **优先使用HTML模板**：利用熟悉的语法和可视化预览优势
2. **合理的项目结构**：按功能模块组织代码，提高可维护性
3. **事件处理封装**：将业务逻辑与界面分离，增强代码可读性
4. **Grid布局为主**：使用精确的二维布局控制系统
5. **高效的状态管理**：合理组织状态结构，优化监听策略
6. **性能优化意识**：减少不必要的重建和更新操作

### 实践建议

- 从简单的HTML模板开始，逐步引入Builder API的动态特性
- 采用模块化的处理器设计，便于团队协作
- 利用Grid布局的精确控制能力，避免深层嵌套
- 实施适当的状态监听策略，平衡功能需求和性能要求
- 关注组件生命周期管理，及时清理资源

通过遵循这些最佳实践，开发者可以充分发挥libuiBuilder框架的优势，构建出既美观又高效的桌面应用程序。